1. this에 관해 설명하시오.

2. local storage(브라우저 저장소)에 관해 설명하시오.

3. Javascript는 어떤 언어인가요?
   싱글 쓰레드 언어입니다.

하지만 실제사용시에는 멀티 스레드처럼 사용하는데 어떻게 그렇게 사용하나요?
비동기함수는 실행컨텍스트가 아닌 멀티쓰레드인 브라우저의 이벤트 루프에 의하여 일정시간이 지난뒤
태스크 큐로 옮겨집니다. 그리고 콜 스택에서 스택이 다 제거된 뒤에 이벤트루프에 의하여 콜스택으로 옮겨져 실행됩니다.
이 과정에서 자바스크립트엔진 싱글쓰레드로 작동하지만 브라우저는 멀티쓰레드임으로 자바스크립트도 멀티쓰레드인것처럼
작동하게 되는 것입니다.

비동기적으로 실행되는 것을 동기적으로 사용하는 방법은?
(generator 함수를 사용하여 코드 호출을 조작하여 동기적으로 사용하는 방법이 있고 이를 간편화한
promise 객체를 반환하는 async/await 키워드를 사용하여 동기적으로 사용할 수 있는 방법이 있습니다.
)

6. 이벤트 전파,이벤트 캡처링,이벤트 버블링,이벤트 위임에 대해 연관지어 설명해주시고 이벤트 위임을 사용하였을 때 장점을 알려주세요.

   이벤트 캡처링은 이벤트 객체가 window에서 시작하여 이벤트 타깃 방향으로 이동하는 단계이고
   타깃 단계는 이벤트 객체가 이벤트 타깃에 도달했을 때의 단계이며
   이벤트 버블링은 도달한 뒤 window 방향으로 이동하는 단계입니다.
   즉, 이벤트 객체는 DOM 트리를 돌아다니며 전파되기 때문에 지정된 요소외에서도
   이벤트 타깃을 캐치할 수 있습니다.

이러한 작동원리를 이용하여 이벤트를 발생시킨 요소에서 뿐만 아니라 상위 DOM요소에서도 이벤트 객체를 캐치함으로써 이벤트 타깃을 캐치할 수 있습니다.
이는 많은 DOM요소에 이벤트 핸들러를 등록해야할 경우 이들의 부모인 상위 요소에
이벤트핸들러를 등록해줌으로써 생산적인 코드를 구현할 수 있습니다.

또한 만약 이러한 이벤트 위임을 막고 싶다면 이벤트 전파를 중지시키는
이벤트객체의 stopPropagation() 메서드를 사용하면 됩니다.

## 7. 실행컨텍스트

8. 프로토타입에 관해 설명해주세요.

> call,bind,apply 메서드에 관해 설명해주세요.

> 프레임워크와 라이브러리의 차이

## 10. Cors와 Cors오류를 해결하기 위한 방법

CORS는 서로 다른 origin으로 네트워크 요청을 하여도 CORS 규칙을 지킨다면 리소스를 응답받을 수 있도록 하며 이에 대한 정책을 규정한 기능이다.

이 때 서버에서 허용 origin 설정(Access-Control-Allow-Origin)을 제대로 해주지 않았다면 CORS에러가 발생할 수 있다.

때문에 해당 에러를 해결하기 위해서는 서버에서 허용 origin을 알맞게 해주면 된다.(예)Access-Control-Allow-Origin: https://requestorigin.com)

다른 방법은 웹팩 개발 서버에서 proxy기능을 사용하는 방법이 있다.
proxy로 요청을 보내고자하는 서버를 입력해주면 나의 개발 서버로 요청을 보냈을 때 proxy가 대신하여 요청을 보내고자하는 서버에 요청을 보내고 응답을 받아 전달해준다.
(다만 proxy 설정 서버가 production모드인 경우 해결이 안될 수 있으니 로컬 서버로 설정할 경우에 사용하는 것이 좋다.
production 모드에서도 사용하고 싶다면 client orgin과 server origin이 같은 경우에 사용하는 것이 권장된다.)
)
**Reference**

- https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#the_http_request_headers

- https://evan-moon.github.io/2020/05/21/about-cors/#simple-request

- https://stackoverflow.com/questions/52877492/proxy-not-working-for-create-react-app-in-production

## **클로저**가 무엇인지 말해보시오.

```
클로저는 함수와 그 함수가 선언된 렉시컬 환경의 조합입니다.
일반적 중첩함수가 외부함수의 변수를 참조하고 있으며 외부함수보다 생명주기가 길 때 이를 클로저라고합니다.
외부함수보다 중첩함수가 더 오래유지되는 경우 중첩함수는 이미 생명 주기가 종료된 외부 함수의 변수를 참조할 수 있습니다.
(중첩함수가 외부함수의 변수를 참조할 수 있는 이유는 중첩함수가 선언된 렉시컬 환경을 기억하고 있기 때문입니다.
함수정의가 평가될 때 해당 함수의 실행컨텍스트보다 상위 실행 컨텍스트에 의하여 평가되어 함수객체가 생성되는데 이때 함수객체는 상위 실행컨텍스트를 기억하고 있습니다.
그리고 어떤 함수의 실행컨텍스트가 종료되었다고 해도 자신을 참조하고 있다면 함수의 렉시컬환경은 소멸되지 않습니다.
그렇기 때문에 외부함수가 종료되었음에도 불구하고 중첩함수가 외부함수를 기억하고 있기 때문에 외부함수의 변수를 참조할 수 있는 것입니다.)

```

```js
//클로저
const increase = (function () {
  let num = 0;
  return function () {
    return num++;
  };
})();

//호출할 때마다 중첩함수가 호출됨. num은 초기화되지않고 기억되고 있음.
increase(); // 1
increase(); // 2
increase(); // 3
```

## 호이스팅에 대해 설명하시오.

```
호이스팅이란 식별자를 정의,선언하는 코드 이전에 참조할 수 있는 경우를 말합니다.
자바스크립트 코드는 순차적으로 실행되기에 앞서 평가 단계가 먼저 이루어집니다.

평가 단계에서는 함수 선언문, var 키워드로 선언한 변수가 평가되어
함수 객체가 형성되고 변수는 undefined로 초기화됩니다.
이러한 이유로 선언문 이전에 식별자를 참조할 수 있고 이를 호이스팅이라합니다.

(함수의 경우 함수 호이스팅이라 하고 변수의 경우 변수 호이스팅이라 합니다.
단, 함수 호이스팅의 경우 함수 선언문으로 정의된 함수만이 함수 호이스팅이되며
함수 표현식(리터럴)으로 정의된 함수는 변수 호이스팅이 되는 것을 인지해야합니다.
)
```

## 크로스 브라우징 이슈가 무엇이고 이를 해결하기 위한 방법은 무엇이 있나요?

```
크로스 브라우징이란 각기 다른 브라우저에서 비슷하게 웹을 보여줄 수 있도록 하는 작업입니다. 브라우저마다 기능 구현에 대한 지원 ,예를 들어 지원하는 언어 문법이 다르기 때문에 같은 코드를 입력한다해도 웹이 보일 수도 안보일수도 있습니다.

이러한 문제를 크로스 브라우징 이슈라하며 이를 해결하기 위해서는 모든 브라우저에서 지원을 하고 있는 방향에 맞춰 기능을 구현하는 것이 이상적입니다.
이를 위한 방법으로는 jquery나 babel , polyfill 등 을 사용하는 방법들이 있습니다.
```
