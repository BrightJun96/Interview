## local storage(브라우저 저장소)에 관해 설명하시오.

## Javascript는 어떤 언어인가요?

싱글 쓰레드 언어입니다.

하지만 실제사용시에는 멀티 스레드처럼 사용하는데 어떻게 그렇게 사용하나요?
비동기함수는 실행컨텍스트가 아닌 멀티쓰레드인 브라우저의 이벤트 루프에 의하여 일정시간이 지난뒤
태스크 큐로 옮겨집니다. 그리고 콜 스택에서 스택이 다 제거된 뒤에 이벤트루프에 의하여 콜스택으로 옮겨져 실행됩니다.
이 과정에서 자바스크립트엔진 싱글쓰레드로 작동하지만 브라우저는 멀티쓰레드임으로 자바스크립트도 멀티쓰레드인것처럼
작동하게 되는 것입니다.

비동기적으로 실행되는 것을 동기적으로 사용하는 방법은?
(generator 함수를 사용하여 코드 호출을 조작하여 동기적으로 사용하는 방법이 있고 이를 간편화한
promise 객체를 반환하는 async/await 키워드를 사용하여 동기적으로 사용할 수 있는 방법이 있습니다.
)

## 이벤트 전파,이벤트 캡처링,이벤트 버블링,이벤트 위임에 대해 연관지어 설명해주시고 이벤트 위임을 사용하였을 때 장점을 알려주세요.

이벤트 캡처링은 이벤트 객체가 window에서 시작하여 이벤트 타깃 방향으로 이동하는 단계이고
타깃 단계는 이벤트 객체가 이벤트 타깃에 도달했을 때의 단계이며
이벤트 버블링은 도달한 뒤 window 방향으로 이동하는 단계입니다.
즉, 이벤트 객체는 DOM 트리를 돌아다니며 전파되기 때문에 지정된 요소외에서도
이벤트 타깃을 캐치할 수 있습니다.

이러한 작동원리를 이용하여 이벤트를 발생시킨 요소에서 뿐만 아니라 상위 DOM요소에서도 이벤트 객체를 캐치함으로써 이벤트 타깃을 캐치할 수 있습니다.
이는 많은 DOM요소에 이벤트 핸들러를 등록해야할 경우 이들의 부모인 상위 요소에
이벤트핸들러를 등록해줌으로써 생산적인 코드를 구현할 수 있습니다.

또한 만약 이러한 이벤트 위임을 막고 싶다면 이벤트 전파를 중지시키는
이벤트객체의 stopPropagation() 메서드를 사용하면 됩니다.

## call,bind,apply 메서드에 관해 설명해주세요.

## 호이스팅에 대해 설명하시오.

```
호이스팅이란 식별자를 정의,선언하는 코드 이전에 참조할 수 있는 경우를 말합니다.
자바스크립트 코드는 순차적으로 실행되는 런타임단계에 앞서 평가 단계가 먼저 이루어집니다.

평가 단계에서는 함수 선언문, var 키워드로 선언한 변수 등 식별자들이 평가되어
함수의 경우 함수 객체가 형성되고 변수의 경우 변수는 undefined로 초기화됩니다.
이러한 이유로 선언문 이전에 식별자를 참조할 수 있고 이를 호이스팅이라합니다.

(함수의 경우 함수 호이스팅이라 하고 변수의 경우 변수 호이스팅이라 합니다.
단, 함수 호이스팅의 경우 함수 선언문으로 정의된 함수만이 함수 호이스팅이되며
함수 표현식(리터럴)으로 정의된 함수는 변수 호이스팅이 되는 것을 인지해야합니다.
)
```

## 크로스 브라우징 이슈가 무엇이고 이를 해결하기 위한 방법은 무엇이 있나요?

```
크로스 브라우징이란 각기 다른 브라우저에서 비슷하게 웹을 보여줄 수 있도록 하는 작업입니다. 브라우저마다 기능 구현에 대한 지원 ,예를 들어 지원하는 언어 문법이 다르기 때문에 같은 코드를 입력한다해도 웹이 보일 수도 안보일수도 있습니다.

이러한 문제를 크로스 브라우징 이슈라하며 이를 해결하기 위해서는 모든 브라우저에서 지원을 하고 있는 방향에 맞춰 기능을 구현하는 것이 이상적입니다.
이를 위한 방법으로는 jquery나 babel , polyfill 등 을 사용하는 방법들이 있습니다.
```

## 스코프(Scope | 유효범위)

- 식별자의 유효범위
- 자바스크립트가 식별자를 식별할 수 있는 기준
- 상위 스코프에서 선언된 식별자는 하위 스코프에서 참조할 수 있지만  
  하위 스코프에서 선언된 식별자를 상위스코프에서 참조할 수 는 없다.
- 스코프를 나누는 기준은 함수 레벨 스코프가 있고 블럭 레벨 스코프가 있다.

**Detail**

- 식별자는 자신의 선언된 위치에 따라 다른 코드가 자신을 참조할 수 있는 범위가 달라진다.
  이를 스코프라고 한다

- 변수를 참조할 때 자바스크립트 엔진은 스코프 체인을 통해 **상위 스코프 방향으로 이동**하며 선언된 변수를 검색한다.  
  이 때문에 상위 스코프에서 하위 스코프의 식별자를 참조할 수 없는 것이다.

- 함수레벨 스코프는 스코프를 나누는 기준이 함수이고 블럭 레벨 스코프는 스코프를 나누는 기준이 모든 블럭(if,for,while,try/catch 등)이 된다.

- 동적스코프, 렉시컬스코프
  - 동적 스코프 | 함수의 호출 위치 기준에 따라 스코프를 결정
  - 렉시컬 스코프 | 함수의 선언 위치 기준에 따라 스코프를 결정
  - 자바스크립트는 렉시컬 스코프를 따른다.

## 실행컨텍스트

- 여러 식별자들을 평가하고 등록하여 코드를 실행할 수 있게 하는 컨텍스트
- 실행 컨텍스트에 따라 코드의 실행순서를 결정
- 코드의 실행순서는 실행컨텍스트 스택(콜 스택)에서 관리된다.
- 실행 컨택스트 스택에는 전역 컨텍스트부터 시작하여 이하 컨텍스트를 차례로 추가되어 실행되며  
  역순으로 컨텍스트가 제거된다.

  **Detail**

- 자바스크립트 엔진의 소스 코드 처리 과정

  - 코드 평가 단계
  - 코드 실행 단계(런타임)
    코드 평가단계에서는 실행컨텍스트가 생성되고 변수,함수 등의 선언문이 먼저 실행되어 식별자가 실행 컨텍스트에 등록된다.

- 실행컨텍스트는 콜 스택(실행컨텍스트 스택)과 렉시컬 환경으로 구성되어 있다.
  - 콜스택은 코드의 실행순서를 관리하고 렉시컬환경은 식별자와 스코프를 관리한다.
  - 렉시컬 환경은 스코프를 구분하여 식별자를 등록하고 관리하는 저장소 역할을 하는 스코프의 실체이다.

## 클로저

- 함수와 해당 함수가 선언된 렉시컬 환경의 조합
- 외부 함수가 실행컨텍스트에서 제거됬음에도 불구하고 중첩함수가 상위 렉시컬 환경을 기억하고 있기 때문에  
  외부 함수의 식별자값을 내부 중첩함수가 사용할 수 있게 하는 원리
- 상태를 안전하게 은닉하고 특정 함수에게만 상태 변경 허용
  **Detail**
- 함수가 선언되면 함수는 자신이 선언된 상위 스코프를 기억하고 있다.
- 중첩함수가 외부함수의 자유변수를 참조하고 있어서 종료되지 못하고 있는 것을 비유적으로 갇혀있다하여 클로저이다.
- 부수효과를 억제하고자하는 함수형 프로그래밍에서 적극활용(외부 변수를 오염시키지 않음)
- 즉시 실행함수와 사용한다. 즉시 실행 함수는 한번만 호출하고 종료된다.  
  즉시 실행함수와 사용하고자하는 변수를 선언하고 중첩함수는 해당 변수를 사용한다.

```js
const increase = (function () {
  let num = 0;
  return function () {
    return num++;
  };
})();

increase();
```

## this

## 프로토타입

## ES6이상 문법

## Babel,Webpack
