## Javascript는 어떤 언어인가요?

- 싱글 쓰레드 언어입니다.

하지만 실제사용시에는 멀티 스레드처럼 사용하는데 어떻게 그렇게 사용하나요?
비동기함수는 실행컨텍스트가 아닌 멀티쓰레드인 브라우저의 이벤트 루프에 의하여 일정시간이 지난뒤
태스크 큐로 옮겨집니다. 그리고 콜 스택에서 스택이 다 제거된 뒤에 이벤트루프에 의하여 콜스택으로 옮겨져 실행됩니다.
이 과정에서 자바스크립트엔진 싱글쓰레드로 작동하지만 브라우저는 멀티쓰레드임으로 자바스크립트도 멀티쓰레드인것처럼
작동하게 되는 것입니다.

비동기적으로 실행되는 것을 동기적으로 사용하는 방법은?
(generator 함수를 사용하여 코드 호출을 조작하여 동기적으로 사용하는 방법이 있고 이를 간편화한
promise 객체를 반환하는 async/await 키워드를 사용하여 동기적으로 사용할 수 있는 방법이 있습니다.
)

- 자바스크립트는 동적 타입언어  
  할당에 의해 타입이 결정된다.  
  그리고 재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있다.  
  이는 어떤 데이터 타입의 값도 할 수 있는 자유로움이 있지만  
  프로젝트 규모가 커졌을 때의 변수의 데이터 타입을 추정하기 어렵다는 단점이 있다.  
  이를 보완하기 위해 타입스크립트가 존재한다.  
  타입스크립트는 각 식별자에 타입을 지정해줄 수 있다.

## var,let,const의 차이

```
첫째로, 스코프 분류 기준이 다릅니다.
var는 함수 레벨 스코프를 가졌고 let,const는 블록 레벨 스코프를 가졌습니다.
함수 레벨 스코프는 함수 코드 블록만이 식별자의 유효 범위인 스코프를 나누는 기준이고
블록 레벨 스코프는 모든 코드 블록이 스코프를 나누는 기준입니다.

때문에 var 키워드로 선언한 변수는 함수 코드 블록을 기준으로 스코프가 나뉘고
let,const 키워드로 선언한 변수는 모든 코드 블록을 기준으로 스코프가 나뉩니다.

둘째로, 중복선언의 차이입니다.
var 키워드는 변수를 중복선언할 수 있지만,
let/const키워드로 선언한 변수는 중복선언할 수 없습니다.

셋째로, 호이스팅의 차이입니다.
var 키워드로 선언한 변수는 코드 평가 단계에서 선언과 초기화 과정
(undefined로 초기화됨)이 동시에 이루어져
선언문 이전에 참조할 수 있습니다.

여기서 이전에 참조할 수 있는 이유는 평가과정은 코드가 순차적으로 실행되는 런타임이전에 먼저 실행되기 때문입니다.

let,const 키워드로 선언한 변수는 평가 단계에서 선언 과정만 이루어지기 때문에
(런타임에서 선언문을 만났을 때 초기화단계가 이루어짐.)
선언문 이전에 일시적 사각지대에 빠져 참조할 수 없습니다.

넷째로, 재할당의 차이입니다.
let과 const의 차이는 let 키워드로 선언한 변수는 재할당이 가능하지만
const 키워드로 선언한 변수는 재할당이 불가능합니다.

```

## 이벤트 전파,이벤트 캡처링,이벤트 버블링,이벤트 위임에 대해 연관지어 설명해주시고 이벤트 위임을 사용하였을 때 장점을 알려주세요.

이벤트 캡처링은 이벤트 객체가 window에서 시작하여 이벤트 타깃 방향으로 이동하는 단계이고
타깃 단계는 이벤트 객체가 이벤트 타깃에 도달했을 때의 단계이며
이벤트 버블링은 이벤트 타겟에 도달한 뒤 window 방향으로 이동하는 단계입니다.
즉, 이벤트 객체는 DOM 트리를 돌아다니며 전파되기 때문에 지정된 요소외에서도
이벤트 타깃을 캐치할 수 있습니다.

이러한 작동원리를 이용하여 이벤트를 발생시킨 요소에서 뿐만 아니라 상위 DOM요소에서도 이벤트 객체를 캐치함으로써 이벤트 타깃을 캐치할 수 있습니다.
이는 많은 DOM요소에 이벤트 핸들러를 등록해야할 경우 이들의 부모인 상위 요소에
이벤트핸들러를 등록해줌으로써 생산적인 코드를 구현할 수 있습니다.

또한 만약 이러한 이벤트 위임을 막고 싶다면 이벤트 전파를 중지시키는
이벤트객체의 stopPropagation() 메서드를 사용하면 됩니다.

## call,bind,apply 메서드에 관해 설명해주세요.

- this를 원하고자하는 객체에 바인딩하기위한 방법들
-

- Function.prototype.call
  this로 사용할 객체와 인수 리스트를 인수로 전달받아 함수를 호출한다.
  인수를 쉼표로 구분하여 전달한다
- Function.prototype.apply
  this로 사용할 객체와 인수 리스트를 인수로 전달받아 함수를 호출한다.
  인수를 배열로 전달한다
- Function.prototype.bind
  인자에 this로 사용할 객체만을 할당함으로써 원하는 객체에 바인딩한다.

```js
const obj = {
  value: 100,
  foo() {
    setTimeout(
      function () {
        console.log(this.value);
      }.bind(this),
      100
    );
  },
};
```

## 호이스팅에 대해 설명하시오.

```
호이스팅이란 식별자를 정의,선언하는 코드 이전에 참조할 수 있는 경우를 말합니다.
자바스크립트 코드는 순차적으로 실행되는 런타임단계에 앞서 평가 단계가 먼저 이루어집니다.

평가 단계에서는 함수 선언문, var 키워드로 선언한 변수 등 식별자들이 평가되어
함수의 경우 함수 객체가 형성되고 변수의 경우 변수는 undefined로 초기화됩니다.
이러한 이유로 선언문 이전에 식별자를 참조할 수 있고 이를 호이스팅이라합니다.

(함수의 경우 함수 호이스팅이라 하고 변수의 경우 변수 호이스팅이라 합니다.
단, 함수 호이스팅의 경우 함수 선언문으로 정의된 함수만이 함수 호이스팅이되며
함수 표현식(리터럴)으로 정의된 함수는 변수 호이스팅이 되는 것을 인지해야합니다.
)
```

## 스코프(Scope | 유효범위)

- 식별자의 유효범위
- 자바스크립트가 식별자를 식별할 수 있는 기준
- 상위 스코프에서 선언된 식별자는 하위 스코프에서 참조할 수 있지만  
  하위 스코프에서 선언된 식별자를 상위스코프에서 참조할 수 는 없다.
- 스코프를 나누는 기준은 함수 레벨 스코프가 있고 블럭 레벨 스코프가 있다.

**Detail**

- 식별자는 자신의 선언된 위치에 따라 다른 코드가 자신을 참조할 수 있는 범위가 달라진다.
  이를 스코프라고 한다

- 변수를 참조할 때 자바스크립트 엔진은 스코프 체인을 통해 **상위 스코프 방향으로 이동**하며 선언된 변수를 검색한다.  
  이 때문에 상위 스코프에서 하위 스코프의 식별자를 참조할 수 없는 것이다.

- 함수레벨 스코프는 스코프를 나누는 기준이 함수이고 블럭 레벨 스코프는 스코프를 나누는 기준이 모든 블럭(if,for,while,try/catch 등)이 된다.

- 동적스코프, 렉시컬스코프
  - 동적 스코프 | 함수의 호출 위치 기준에 따라 스코프를 결정
  - 렉시컬 스코프 | 함수의 선언 위치 기준에 따라 스코프를 결정
  - 자바스크립트는 렉시컬 스코프를 따른다.

## 실행컨텍스트

- 여러 식별자들을 평가하고 등록하여 코드를 실행할 수 있게 하는 컨텍스트
- 실행 컨텍스트에 따라 코드의 실행순서를 결정
- 코드의 실행순서는 실행컨텍스트 스택(콜 스택)에서 관리된다.
- 실행 컨택스트 스택에는 전역 컨텍스트부터 시작하여 이하 컨텍스트를 차례로 추가되어 실행되며  
  역순으로 컨텍스트가 제거된다.

  **Detail**

- 자바스크립트 엔진의 소스 코드 처리 과정

  - 코드 평가 단계
  - 코드 실행 단계(런타임)
    코드 평가단계에서는 실행컨텍스트가 생성되고 변수,함수 등의 선언문이 먼저 실행되어 식별자가 실행 컨텍스트에 등록된다.

- 실행컨텍스트는 콜 스택(실행컨텍스트 스택)과 렉시컬 환경으로 구성되어 있다.
  - 콜스택은 코드의 실행순서를 관리하고 렉시컬환경은 식별자와 스코프를 관리한다.
  - 렉시컬 환경은 스코프를 구분하여 식별자를 등록하고 관리하는 저장소 역할을 하는 스코프의 실체이다.

## 클로저

- 함수와 해당 함수가 선언된 렉시컬 환경의 조합
- 외부 함수가 실행컨텍스트에서 제거됬음에도 불구하고 중첩함수가 상위 렉시컬 환경을 기억하고 있기 때문에  
  외부 함수의 식별자값을 내부 중첩함수가 사용할 수 있게 하는 원리
- 상태를 안전하게 은닉하고 특정 함수에게만 상태 변경 허용
  **Detail**
- 함수가 선언되면 함수는 자신이 선언된 상위 스코프를 기억하고 있다.
- 중첩함수가 외부함수의 자유변수를 참조하고 있어서 종료되지 못하고 있는 것을 비유적으로 갇혀있다하여 클로저이다.
- 부수효과를 억제하고자하는 함수형 프로그래밍에서 적극활용(외부 변수를 오염시키지 않음)
- 즉시 실행함수와 사용한다. 즉시 실행 함수는 한번만 호출하고 종료된다.  
  즉시 실행함수와 사용하고자하는 변수를 선언하고 중첩함수는 해당 변수를 사용한다.

```js
const increase = (function () {
  let num = 0;
  return function () {
    return num++;
  };
})();

increase();
```

## 객체 지향 프로그래밍,함수 지향 프로그래밍

- 객체 지향 프로그래밍 | 객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임

  - 객체 지향 프로그래밍의 핵심은 상속이다.
    어떤 객체의 속성을 다른 객체에 전달하기 위해 객체의 속성(프로퍼티,메서드)을 상속한다.

- 함수 지향 프로그래밍 | 함수의 집합으로 프로그래밍을 표현하려는 프로그래밍 패러다임
  - 각 함수를 부수효과가 없는 순수함수를 구성하는 것을 추구한다.
  - 부수효과란 외부의 값을 함수 내부에서 변경하는 것을 말한다.

**Detail**

- 객체란 | 여러가지 속성을 하나의 단위로 구성한 복합적인 자료구조

## 프로토타입(prototype | 원형)

- 코드의 재사용성을 위해 **객체의 여러가지 특성을 다른 객체에게 상속**해줄 수 있는 기능
- 자바스크립트는 프로토타입 기반 객체 기반 프로그래밍 언어
- 자바스크립트는 프로토타입을 기반으로 객체의 속성을 전달한다.
- 프로토타입으로 속성을 전달함으로써 코드의 재사용성을 높일 수 있다.

**Detail**

- 자바스크립트를 이루고 있는 거의 모든 것이 객체(원시값을 제외한 나머지값들은 모두 객체)

- 프로토타입을 상속받은 객체는 상속해준 상위 객체의 속성들을 사용할 수 있다.

- 어떠한 속성을 상속하고 싶을 때에는 **생성자함수내에서** **객체.prototpye.상속하고자하는 속성**

- 객체가 생성될 때 **객체 생성 방식에 따라 프로토타입이 결정**된다.

  - 객체 리터럴에 의해 생성된 객체 | 프로토타입 => **Object.prototype**
    Object 객체가 상속한 속성들을 전달받아 사용할 수 있다.

  - 함수 리터럴에 의해 생성된 함수 | 프로토타입 => **Function.prototype**

  - 배열 리터럴에 의해 생성된 배열 | 프로토타입 => **Array.prototype**

- 생성자 함수는 자신의 프로토타입을 **prototype**을 통해 조회할 수 있고  
  프로토타입은 **자신의 constructor 프로퍼티**를 통해 생성자함수에 접근할 수 있다.

- 프로토타입의 최상위 객체는 Object.prototype이다.

## this(자기 참조 변수)

- 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기참조변수

- this를 통해 자신이 속한 객체나 자신이 생성할 인스턴스의 프로퍼티나 메서드를 참조할 수 있다.

- 자바스크립트 엔진에 의해 암묵적으로 생성되며 어디서든 참조할 수 있다.

- this 바인딩은 함수 호출 방식에 따라 동적으로 결정된다.
  - 전역에서 this는 전역 객체 window를 가리킨다.
  - 생성자 함수가 아닌 일반 함수 내부에서 this는 호출됬을 때 전역객체 window를 가리킨다.
  - 생성자 함수 내부에서 this는 인스턴스를 가리킨다
  - 객체 메서드내부에서 this는 메서드를 호출한 객체를 가리킨다.
  - 화살표 함수내에 this는 상위 스코프의 this를 참조한다.  
    이는 콜백함수의 this가 외부함수의 this가 다르기 때문에 발생하는 문제를 해결하기 위해 의도적으로 설계된 것

```js
const circle = {
  radius: 5,
  diameter() {
    return this.circle * 2;
  },
};


function Circle(radius){
  this.radius = radius,
}

Circle.prototype.diameter = this.radius * 2
```

## Babel,Webpack

Babel(Transpiler)

- 최신문법이 지원이 안되는 브라우저에 최신문법을 지원하기 위하여 사용하는 기술
- 최신문법(ES6이상 문법)을 ES5사양의 코드로 변환 가능

Webpack(bundler)

- 여러가지 리소스들을 각각 해당하는 하나의 파일로 번들링하는 모듈 번들러(예 | 여러 자바스크립트 파일을 하나의 파일로 번들로)

주로 Webpack에 Babel을 로드하여 사용한다

## 자바스크립트 데이터 타입

- 자바스크립트는 6개의 원시타입과 객체타입으로 7개의 데이터타입이 있다.

- 원시타입은 숫자,문자열,불리언,undefined,null,symbol 타입이 존재한다.

- 이 타입들은 상황에 따라 동적으로 변환될 수 있는데 이를 암묵적 타입변환이라 한다.  
  예를 들어 ,불리언값이 들어가야하는 if문이나 while문에 true와 false가 아닌 null,undefined,빈문자열이 들어가면  
  false로 타입이 변환되고  
  일반 문자열 및 0이 아닌 숫자 등을 할당하면 해당 값은 true로 타입이 변환된다.

- 원시값을 할당한 변수들은 각 객체 프로토타입을 상속받은 것처럼 프로퍼티,메서드를 사용할 수 있다.  
  이는 래퍼 객체로 하여 자바스크립트 엔진이 임시적으로 이 원시값들을 객체화하어 사용할 수 있게 한다.

## 클래스

ES6에 만들어진 문법으로 생성자 함수와 유사하게 객체를 생성해낼 수 있다.

## 함수

- 함수는 일급객체이다.
  - 리터럴로 생성 가능
  - 변수나 자료구조(객체,배열)에 저장 가능
  - 함수의 매개변수에 전달 가능
  - 함수의 반환값으로 사용 가능

## ES6이상

- 화살표 함수
- Rest 파라미터
- 구조 분해
- spread연산자
  (인수들의 양이 많거나 리액트에서 전달할 props가 많을 때 유용함.)
- 객체에서의 메서드 축약
- let,const
- 클래스
- 탬플릿 리터럴
- 프로미스
- async/await
- 모듈 import/export
- 제너레이터
- for..of
- Map/Set
- 심벌
- proxy
- null 병합연산자
- 옵셔널 체이닝 연산자
