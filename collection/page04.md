## 리액트란 무엇이고 왜 사용하는가?

리액트란 자바스크립트 라이브러리이고 Virtual Dom, 효율적인 UI를 구성, 컴포넌트를 기반 이라는 핵심적인 특징을 가지고 있다.
기존 자바스크립트로만 만든 웹에서 데이터양이 많고 많은 UI로 구성되어있을때
임의의 데이터가 변경되면 수많은 UI가 리플로우,리페인팅되며 렌더트리를 재성성해야한다.

만약 사용자와 상호작용이 많은 웹이라면 변화가 있을 때마다 위와 같이 렌더트리를 재성성하여 웹 성능을 지연시킬 수 있다.
하지만 리액트는 Virtual Dom을 사용하여 변경되는 요인만 효율적으로 변경해줘 위와 같은 상황에서 성능을 최적화 할 수 있게 한다.

또한 컴포넌트를 기반으로 하여 체계적 UI를 구성할 수 있는 장점이 있다.

다만 규모가 작고 정적이며 사용자와 상호작용이 없는 웹이라면 굳이 리액트를 사용할 필요는 없다.

## SPA

SPA란 Single Page Application으로 하나의 html문서안에서 프로젝트를 진행할 수 있는 앱이다.
리액트는 SPA로써 하나의 루트 html요소에 바인딩하여 컴포넌트를 중첩하여 앱을 구성한다.

- 여러 화면을 보여주어야할 때마다 각 html문서를 만들지않고도 컴포넌트를 보여줘 번거로움을 줄일 수 있다.

## Virtual Dom

가상 돔으로써 효율적인 돔 변경을 할 수 있게 해준다.

기존 돔의 경우에 변경이 있을 때마다 렌더트리가 전체적으로 리플로우,리페인트되지만
가상 돔은 이전 가상돔과 새로 만들어진 가상돔을 비교해 변경되는 부분만 실제 돔에 반영하여
돔의 효율적인 변경에 도움을 준다.

**Detail**

- 리액트는 휴리스틱 알고리즘을 사용한다. 다음 2가지 상황을 기반으로 작동한다.
  - 다른 타입의 두 요소는 다른 트리를 생성한다.
  - 개발자는 key prop을 통해 변경되는 부분을 나타낼 수 있다.
- 기본 루트 요소와 변경되는 루트 요소를 비교하여 변경사항이 있을 때마다 새로운 가상 돔 트리를 형성한다.
- 이전 가상 돔트리와 새로운 가상 돔 트리를 비교하여 변경되는 부분만 실제 돔에 반영한다.
- 이전 가상 돔트리는 버린다.
- 변경사항이 있을 때마다 새로운 가상 돔트리가 생성되더라도 이전 state값은 유지가 된다.

- 요소의 속성과 스타일 값은 변경되면 해당 요소를 버리지않고 변경되는 값만 변경해준다.

**Ref**

- https://reactjs.org/docs/reconciliation.html

## LifeCycle Method

클래스형 컴포넌트에서만 존재하는 생명주기 메서드로 컴포넌트가 나타날때부터 사라질때까지의 주기를 메서드로 나타낸 메서드이다.
대표적인 세가지 메서드로 컴포넌트가 나타날 때 특정한 작업을 할 수 있는 componentDidmount,
컴포넌트가 업데이트될 때 특정 작업을 할 수 있는 componentDidUpdate,
컴포넌트가 사라질 때 특정 작업을 할 수 있는 componentwillMount메서드들이 있다.

컴포넌트가 업데이트가 될지 말지를 결정해주는 componentshouldupdate를 이용하여 상황에 따라 컴포넌트의 업데이트 여부를 결정해
최적화해줄 수 있다.

모두 필수적으로 사용해야하는 메서드들은 아니며 필요에 따라 선택적으로 사용할 수 있다.

## props,state

props는 컴포넌트끼리 데이터를 전달하기 위하여 입력해주는 속성이다.
state는 지속적으로 변경되는 데이터를 관리하기 위하여 사용하는 상태값이다.
둘은 보통 연관지어 쓰이는데 props로 state를 전달하여 사용된다.

또한 이 두가지 속성이 업데이트될 때 컴포넌트는 리렌더링된다.

(**state의 특징**

- state는 setState로 업데이트되어야한다.
  직접적으로 state를 변경하면 컴포넌트가 업데이트되지않는다.

- setState는 비동기적으로 작동한다.

- state를 업데이트할 때 불변성을 유지하여야한다.
  이전 값을 변경하면 virtual dom이 이전값과 변경되는 값을 비교하지 못하여 업데이트 되지못한다.
  )

## JSX

리액트 컴포넌트내에서 사용하는 자바스크립트 변환 문법이며 바벨에 의해 자바스크립트 본 문법으로 트랜스파일링된다.
형태는 html과 비슷한 형태를 가지고 있으며 각 요소는 createElement를 통해 만들어진다.

## 클래스형 컴포넌트와 함수형 컴포넌트의 차이

클래스형 컴포넌트는 상태관리를 setState로 관리하며 생명주기 메서드를 사용한다.
함수형 컴포넌트는 상태관리를 useState를 통해 관리하며 생명주기 메서드와 비슷한 useEffect를 사용하고 많은 기능을 훅을 통해 관리한다.

클래스형 컴포넌트보다 함수형 컴포넌트가 사용법이 간단하고 지원적인 기능이 많아 함수형을 더 많이 사용한다.

## react에서 state를 setState를 사용하여 변경해주는 이유와 불변성을 유지해야하는 이유?

state를 직접적으로 변경하게 되면 리액트는 상태값이 변경되는 것을 캐치하지 못하기 때문이다.
때문에 state를 직접변경하지말고 setState로 관리해주어야 한다.

또한 불변성을 지키지않고 이전 상태값을 변경한다면 가상 돔이 이를 비교하지 못하여 업데이트가 안될 수가 있다.
덧붙혀 최적화를 할 때 (shouldComponentUpdate or React.memo) 이전 상태값과 업데이트되는 상태값을 비교하여
최적화해줄 수 없기도 하다.

**Ref**

- https://reactjs.org/docs/state-and-lifecycle.html#do-not-modify-state-directly

## shouldCompoentUpdate

컴포넌트가 업데이트되야하는지를 결정해주는 메서드이며 false를 반환하면 컴포넌트가 리렌더링되지 않는다.  
이전 props와 변경되는 props 또는 이전 state와 변경되는 state를 비교하여 변경사항이 없을 때 최적화하는 용도로 사용한다.

## 제어 컴포넌트와 비제어 컴포넌트

- html form요소는 내부적으로 state를 가지고 있지만 react에서 form요소들은 그 자체로 state를 갖지않아 setState로 관리해줘야한다.
- form요소의 state를 state값을 선언하여 setState로 관리해주는 컴포넌트를 제어 컴포넌트라고 한다.
- 비제어컴포넌트는 form요소들의 state값을 DOM자체로 관리해주는 컴포넌트를 말한다.
- 제어 컴포넌트에서 각 form요소에 state에 대한 이벤트 핸들러를 관리해주기 번거로울 때 비제어 컴포넌트를 사용하곤 한다.
- 비제어컴포넌트는 ref를 사용하여 form요소를 관리한다.
  **Ref**
  - https://reactjs.org/docs/forms.html#controlled-components
  - https://reactjs.org/docs/uncontrolled-components.html
  - https://goshacmd.com/controlled-vs-uncontrolled-inputs-react/

## 순수 컴포넌트(리렌더링 방지)

- 해당 컴포넌트 외부의 상태값을 참조하지하거나 변경하지 않는 컴포넌트
- props값과 state값이 변경되지 않았을 때 리렌더링되지 않게 하는 컴포넌트

**Ref**

- https://medium.com/technofunnel/working-with-react-pure-components-166ded26ae48

## 에러 바운더리

- 에러 바운더리는 에러가 발생하는 해당 컴포넌트에서 에러를 잡을 수 있게 하는 컴포넌트를 지칭한다.
- 에러가 발생한 컴포넌트에서 에러를 캐치하고, 로그에 에러를 띄워준다.
- 에러 바운더리는 렌더링, 라이프 사이클 동안 에러를 캐치해준다.

**Ref**

- https://reactjs.org/docs/error-boundaries.html

## 리액트 렌더링 향상을 위해 할 수 있는 것은?

불필요한 리렌더링을 방지하는 것이다.
이를 위해 메서드로 클래스형컴포넌트에서는 shouldComponentUpdate가 있고 함수형 컴포넌트에서는 React.memo,useCallback,useMemo등
메모이제이션을 하여 컴포넌트 및 함수 등을 이전에 사용했던 값을 기억하여 불필요한 리렌더링을 방지한다.

## key props를 사용하는 이유?

가상 돔이 효율적으로 변경되는 DOM을 비교하기 위해서이다.
key가 없을 때는 가상 돔이 비교하는 과정에서 리스트를 순차적으로 비교하지만
key가 있다면 해당 값을 이용하여 어떤 변화가 일어났는지 빠르게 알아낼 수 있다.

## React.memo,useMemo,useCallback

이 셋은 메모이제이션을 할 수 있는 기능을 가지고 있다.
메모이제이션을 새로운 값을 만들어내지않고 이전 값을 기억하여 사용하는 기능이다.

React.memo는 컴포넌트에 사용하여 컴포넌트에 변경사항이 없을 때 (state나 props의 변화가 없을 때),
해당 컴포넌트를 리렌더링해주지 않어 리렌더링 최적화를 해줄 수 있고,

useCallback는 함수를 기억하여 무조건 함수를 생성하는 것이 아닌 새로 함수를 생성해야할 때만 함수를 생성하게 해준다.

useMemo는 어떠한 값을 기억하여 변경되는 사항이 없으면 이전값을 사용하고 값이 바뀌면 바뀌는 값을 사용하게 해준다.

## Context API란?

컴포넌트내에서 데이터를 전역적으로 사용하게 해줄 수 있는 react api이다.
리액트 특성상 컴포넌트끼리 데이터를 전달하기 위해서 props사용하여 전달해야하는데
이 때 컴포넌트의 중첩도가 높다면 props를 여러번 거쳐서 전달해야한다.(이를 prop drilling이라 한다)

때문에 이러한 번거로움을 줄이기 위해 사용할 수 있는 방법으로 context api가 제시된다.
대표적인 API로 Provider,consumer,context를 중심으로 데이터를 관리해줄 수 있다.

## redux를 사용하는 이유? Redux의 장단점

복잡한 상태를 체계적으로 관리하며 상태값을 전역적으로 사용할 수 있기 때문에 사용한다.
상태값이 여러개라면 이를 useState나 useReducer만으로 관리하기가 쉽지 않다.
하지만 redux를 사용하면 상태값을 컴포넌트별로 구분지어 체계적으로 관리하여 각 state값의 변화를 관찰하기 쉽다.

또한 컴포넌트 구조가 복잡하다면 상태값을 props로 여러번 전달해줘야하기 때문에 가독성,유지보수성에 좋지 않다.
redux는 이러한 상황일 때에 상태값을 필요한 부분에 가져다 쓰도록 store에 담아 전역적으로 관리할 수 있게 해준다.

하지만 상태가 복잡하지 않거나 컴포넌트 구조가 복잡하지 않다면 구성하는 것이 번거로울 수 있기 때문에 사용하지 않는 것이 낫다.

## 미들웨어는 무엇이고 대표적인 미들웨어인 redux saga와 redux thunk를 어떠한 상황에 적절히 사용하면 되는 것인가?

미들웨어는 action이 reducer로 가는 중간에서 action을 캐치하여 side effect와 같은 기능을 해당 action에 추가하여 reducer로 보낼 수 있는 기능이다.
때문에 대표적인 작업인 비동기 로직과 같은 side effect들을 reducer에서 사용할 수 없기때문에 미들웨어에서 실행해야한다.

대표적인 미들웨어로는 thunk와 saga가 있다.

redux-thunk는 특별한 셋업없이 간편하게 사용할 수 있다는 장점이 있으며 RTK에서 default로 지원이 되어 미들웨어 설정없이 사용할 수 있다.  
 다만 로직이 복잡해지면 가독성이 안 좋아지는 콜백헬을 발생시킬 수 있는 가능성 크고 유지보수가 어려워질 수 있다는 점이 있다.  
redux-saga는 thunk에 비해 셋업이 필요하다는 단점이 있다.  
 하지만 로직이 복잡해지고 프로젝트가 커져도 체계적으로 관리할 수 있다는 점이 있다.

단순한 비동기작업 등 미들웨어작업이라면 thunk를 쓰는 것이 낫다.  
saga를 사용하기 위해서는 기본적인 setup이 필요하고 간단한 로직임에도 굳이 불필요한 코드만 늘어날 수 있기 때문이다.  
하지만 프로젝트 규모가 크고 복잡한 로직이라면 saga로 체계적으로 관리해줘도 좋다.

RTK안에서 비동기 로직때문에 미들웨어를 사용하는 경우라면 redux-thunk를 사용하는것이 편하다.
RTK는 redux-thunk를 default로 지원하기 때문에 미들웨어 셋업없이 thunk를 선언하여 사용하면 된다.

**Ref**

- https://www.eternussolutions.com/2020/12/21/redux-thunk-redux-saga/
- https://shinejaram.tistory.com/76
- https://react.vlpt.us/redux-middleware/10-redux-saga.html

## react 18버전 업데이트된 내용이 뭔지 알고 있는지?
