# Interview

## 1. 브라우저 렌더링 과정

0. 임의의 주소를 입력한다.

1. 브라우저는 HTML,CSS,자바스크립트, 이미지, 폰트 파일 등 렌더링에 필요한 리소스를 요청하고 서버로부터 응답을 받는다.

2. 브라우저의 렌더링 엔진은 서버로부터 응답된 HTML과 CSS를 파싱하여 DOM과 CCSOM을 형성하여 이들을 결합한 뒤 렌더 트리를 생성한다.

3. 브라우저의 자바스크립트 엔진은 서버로부터 응답된 자바스크립트를 파싱하여 AST(Abstract Syntax Tree)를 생성하고 바이트코드로 변환하여 실행한다.

4. 렌더 트리를 기반으로 HTML 요소의 레이아웃을 계산하는 플로우와 이를 화면에 그리는 페인팅이 완성됨으로써 렌더링이 완료된다.

**정리**

브라우저는 서버로부터 HTML,CSS 파일을 응답받아 파싱하여 DOM과 CCSOM을 형성합니다.

이들은 렌더링을 위하여 렌더트리로 결합되고 레이아웃을 계산하는 플로우 작업과 HTML요소들을 화면에 그리는 페인트작업을 완료함으로써 렌더링이 됩니다.

플로우 : HTML 요소의 레이아웃을 계산하는 작업
페인트 : HTML 요소를 화면에 그리는 작업

(플로우 작업과 페인트 작업이 반복해서 실행될 수 있는데 이를 리플로우,리페인트라 하며 다음과 같은 경우 실행됩니다.

1. 자바스크립트에 의한 노드추가,삭제
2. 브라우저 창의 리사이징
3. HTML 요소의 레이아웃을 변경을 발생시키는 스타일 변경
   )

## 2. Script 태그를 **head** 태그보다 **body** 태그에 넣는 이유는 무엇이고 태그 삽입 **순서에 상관없이** 태그를 삽입할 수 있는 방법은 무엇이 있을까요?

1. html은 렌더링 엔진에 의해 순차적으로 파싱되며 중간에 다른 파일을 로드하는 link,script 태그 등을 만나면 DOM생성을 중단합니다.

2. DOM의 생성된 후의 위치에 script 태그를 두는 것이 중요합니다.

head태그에 삽입할 경우 DOM트리가 완성되지 않은 상황이기 때문에 자바스크립트 코드 중 DOM API가 쓰일 경우 에러가 발생할 수 있습니다.

때문에 DOM 생성되기전인 head 태그보다 body태그 끝쪽에 위치시키는 것이 좋습니다.

3. 순서에 상관없이 태그를 삽입할 수 있는 방법은 script 태그의 어트리뷰트로 async나 defer을 부여해주면 됩니다. 이는 비동기적으로 script 태그를 실행시킬 수 있으므로 에러를 발생시키지 않습니다.

## 3. **클로저**가 무엇인지 말해보시오.

```
클로저는 함수와 그 함수가 선언된 렉시컬 환경의 조합입니다.
일반적 중첩함수가 외부함수의 변수를 참조하고 있으며 외부함수보다 생명주기가 길 때 이를 클로저라고합니다.
외부함수보다 중첩함수가 더 오래유지되는 경우 중첩함수는 이미 생명 주기가 종료된 외부 함수의 변수를 참조할 수 있습니다.
(중첩함수가 외부함수의 변수를 참조할 수 있는 이유는 중첩함수가 선언된 렉시컬 환경을 기억하고 있기 때문입니다.
함수정의가 평가될 때 해당 함수의 실행컨텍스트보다 상위 실행 컨텍스트에 의하여 평가되어 함수객체가 생성되는데 이때 함수객체는 상위 실행컨텍스트를 기억하고 있습니다.
그리고 어떤 함수의 실행컨텍스트가 종료되었다고 해도 자신을 참조하고 있다면 함수의 렉시컬환경은 소멸되지 않습니다.
그렇기 때문에 외부함수가 종료되었음에도 불구하고 중첩함수가 외부함수를 기억하고 있기 때문에 외부함수의 변수를 참조할 수 있는 것입니다.)

```

```js
//클로저
const increase = (function () {
  let num = 0;
  return function () {
    return num++;
  };
})();

//호출할 때마다 중첩함수가 호출됨. num은 초기화되지않고 기억되고 있음.
increase(); // 1
increase(); // 2
increase(); // 3
```

## 4. 호이스팅에 대해 설명하시오.

```
호이스팅이란 식별자를 정의,선언하는 코드 이전에 참조할 수 있는 경우를 말합니다.
자바스크립트 코드는 순차적으로 실행되기에 앞서 평가 단계가 먼저 이루어집니다.

평가 단계에서는 함수 선언문, var 키워드로 선언한 변수가 평가되어
함수 객체가 형성되고 변수는 undefined로 초기화됩니다.
이러한 이유로 선언문 이전에 식별자를 참조할 수 있고 이를 호이스팅이라합니다.

(함수의 경우 함수 호이스팅이라 하고 변수의 경우 변수 호이스팅이라 합니다.
단, 함수 호이스팅의 경우 함수 선언문으로 정의된 함수만이 함수 호이스팅이되며
함수 표현식(리터럴)으로 정의된 함수는 변수 호이스팅이 되는 것을 인지해야합니다.
)
```

## 5. REST API가 무엇이고 GET과 POST가 어떻게 다르게 쓰이는지 말씀해주세요.

```
REST란 HTTP를 기반으로 클라이언트가 서버의 리소스에 접근하는 방식을 규정한 아키텍처이고, REST API는 REST를 기반으로 구현한 API를 의미합니다.

REST API 중 리소스에 대한 HTTP 요청메서드로써 대표적으로 GET과 POST가 있습니다.

GET은 서버에게 요청하여 모든 리소스나 특정 리소스를 취득할 수 있고
POST는 클라이언트측에서 서버에 없는 특정 리소스를 서버에게 보낼 수 있는 것입니다.

GET은 URL을 통해 요청하고자 하는 데이터를 요청하기 때문에 보안성이 취약할 수 있으며
POST는 데이터를 Body에 담아 보내 데이터가 보이지 않다는 점에서 보안성이 있습니다.

따라서 서버의 리소스를 조회할 때에는 GET, 서버에게 리소스를 보낼 때에는 POST HTTP 요청 메서드를 사용하면 됩니다.
```

## 6. 크로스 브라우징 이슈가 무엇이고 이를 해결하기 위한 방법은 무엇이 있나요?

```
크로스 브라우징이란 각기 다른 브라우저에서 비슷하게 웹을 보여줄 수 있도록 하는 작업입니다. 브라우저마다 기능 구현에 대한 지원 ,예를 들어 지원하는 언어 문법이 다르기 때문에 같은 코드를 입력한다해도 웹이 보일 수도 안보일수도 있습니다.

이러한 문제를 크로스 브라우징 이슈라하며 이를 해결하기 위해서는 모든 브라우저에서 지원을 하고 있는 방향에 맞춰 기능을 구현하는 것이 이상적입니다.
이를 위한 방법으로는 jquery나 babel , polyfill 등 을 사용하는 방법들이 있습니다.
```

## 7. http와 https 차이

http는 웹으로 비추어보았을 때, 클라이언트와 서버가 통신할 수 있도록 하는 프로토콜이다.
프로토콜이란 통신을 위한 규약을 말한다.
http는 html와 같은 여러 가지 리소스등을 교환할 수 있게 해준다.

https는 http의 보안성이 보장된 버전이다.
https위에서 클라이언트와 서버는 안전하게 데이터를 교환할 수 있으며 보안성을 위해 TLS와 SSL을 사용한다.

**Reference**

- https://developer.mozilla.org/en-US/docs/Glossary/Protocol
- https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview
- https://developer.mozilla.org/en-US/docs/Glossary/https
- https://developer.mozilla.org/en-US/docs/Glossary/SSL

## 8. ajax의 개념,탄생동기과 장단점

- 개념
- 탄생동기
- 장단점
- hmlhttprequest

ajax란 자바스크립트를 사용하여 브라우저가 서버에게 비동기 방식으로 데이터를 요청하고,
서버가 응답한 데이터를 수신하여 웹페이지를 동적으로 갱신하는 프로그래밍 방식이다.

ajax등장이전에는 웹페이지가 데이터변경을 할 때에 html전체를 다시 요청하여 받아와 변경되지 않아도 되는 부분까지
불필요하게 응답되어 새로고침과 같이 화면이 깜빡이는 비효율적인 단점이 있었다.

또한 필요한 부분을 업로딩할 때마다 새로운 html을 제작해줘야되니 이 또한 비효율적이다.
(예를 e-commerce 웹사이트로 비추어 보았을 때, 새로운 상품 등록을 할 때마다 그 상품하나 때문에 html을 새로 작성해야한다.
뿐만 아니라 요즘같이 실시간으로 데이터가 업데이트되는 페이스북,인스타그램 등을 보았을 때도 ajax를 사용하지않는 정적웹이면
짧은 시간동안 생성되는 데이터와 비례하여 해당 html문서를 생성해야한다는 것이다.)

하지만 ajax는 필요한 데이터를 비동기적으로 받아와 필요한 부분을 업데이트 할 수 있다.
따라서 필요한 부분만 부분적으로 업데이트되고, 변경될 필요가 없는 부분은 변경되지 않게 할 수 있다.

다만 정적인 웹에서는 처리해야할 데이터가 적기 때문에 요청과 응답이 비교적 빠를 수 있지만
ajax를 사용하는 동적인 웹은 정적인 웹에 비해 요청,응답이 비교적 느려 웹 업로딩이 느릴 수 있다는 단점도 있을 수 있다.

ajax는 XMLHttpRequest를 기반으로 작동한다.  
XMLHttpRequest는 http 비동기 통신을 위한 프로퍼티 및 메서드를 제공한다.
이를 간편하게 사용할 수 있는 API로는 fetch 또는 라이브러리 ajax가 있다.
이는 XML,json,txt,html 등 다양한 데이터 포멧을 주고 받는다.

**reference**

- https://developer.mozilla.org/en-US/docs/Web/Guide/AJAX/Getting_Started
- javascript deep dive
- https://titus94.tistory.com/4

## 9.라이브러리와 프레임워크의 차이

라이브러리나 프레임워크는 둘 다 임의의 기능을 편하게 사용한다던지 등의
문제들을 해결하기 위해 쓰여진 코드의 집합체이다.

둘의 차이점을 프로젝트로 비추어봤을 때
라이브러리는 나의 프로젝트에 부분적으로 도입하여 사용할 수 있지만
프레임워크는 프레임워크라는 틀에서 내가 프로젝트를 구성해야한다는 차이점을 가지고 있다.

즉, 라이브러리는 나의 프로젝트안에서 부족한 부분이 있다면 필요할 때마다 도입할 수 있는 도구이고
프레임워크는 나의 프로젝트를 처음부터 해당 프레임워크에 의존하여 프레임워크를 기반으로 구성하는 도구이다.

**Reference**  
[https://www.freecodecamp.org/news/the-difference-between-a-framework-and-a-library-bd133054023f/](https://www.freecodecamp.org/news/the-difference-between-a-framework-and-a-library-bd133054023f/)

## 10.var,let,const의 차이

```
첫째로, 스코프 분류 기준이 다릅니다.
var는 함수 레벨 스코프를 가졌고 let,const는 블록 레벨 스코프를 가졌습니다.
함수 레벨 스코프는 함수 코드 블록만이 식별자의 유효 범위인 스코프를 나누는 기준이고
블록 레벨 스코프는 모든 코드 블록이 스코프를 나누는 기준입니다.

때문에 var 키워드로 선언한 변수는 함수 코드 블록을 기준으로 스코프가 나뉘고
let,const 키워드로 선언한 변수는 모든 코드 블록을 기준으로 스코프가 나뉩니다.

둘째로, 중복선언의 차이입니다.
var 키워드는 변수를 중복선언할 수 있지만,
let/const키워드로 선언한 변수는 중복선언할 수 없습니다.

셋째로, 호이스팅의 차이입니다.
var 키워드로 선언한 변수는 코드 평가 단계에서 선언과 초기화 과정
(undefined로 초기화됨)이 동시에 이루어져
선언문 이전에 참조할 수 있습니다.

여기서 이전에 참조할 수 있는 이유는 평가과정은 코드가 순차적으로 실행되는 런타임이전에 먼저 실행되기 때문입니다.

let,const 키워드로 선언한 변수는 평가 단계에서 선언 과정만 이루어지기 때문에
(런타임에서 선언문을 만났을 때 초기화단계가 이루어짐.)
선언문 이전에 일시적 사각지대에 빠져 참조할 수 없습니다.

넷째로, 재할당의 차이입니다.
let과 const의 차이는 let 키워드로 선언한 변수는 재할당이 가능하지만
const 키워드로 선언한 변수는 재할당이 불가능합니다.

```
