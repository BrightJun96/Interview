# Interview

## 브라우저 렌더링 과정

0. 임의의 주소를 입력한다.

1. 브라우저는 HTML,CSS,자바스크립트, 이미지, 폰트 파일 등 렌더링에 필요한 리소스를 요청하고 서버로부터 응답을 받는다.

2. 브라우저의 렌더링 엔진은 서버로부터 응답된 HTML과 CSS를 파싱하여 DOM과 CCSOM을 형성하여 이들을 결합한 뒤 렌더 트리를 생성한다.

3. 브라우저의 자바스크립트 엔진은 서버로부터 응답된 자바스크립트를 파싱하여 AST(Abstract Syntax Tree)를 생성하고 바이트코드로 변환하여 실행한다.

4. 렌더 트리를 기반으로 HTML 요소의 레이아웃을 계산하는 플로우와 이를 화면에 그리는 페인팅이 완성됨으로써 렌더링이 완료된다.

**정리**

브라우저는 서버로부터 HTML,CSS 파일을 응답받아 파싱하여 DOM과 CCSOM을 형성합니다.

이들은 렌더링을 위하여 렌더트리로 결합되고 레이아웃을 계산하는 플로우 작업과 HTML요소들을 화면에 그리는 페인트작업을 완료함으로써 렌더링이 됩니다.

플로우 : HTML 요소의 레이아웃을 계산하는 작업
페인트 : HTML 요소를 화면에 그리는 작업

(플로우 작업과 페인트 작업이 반복해서 실행될 수 있는데 이를 리플로우,리페인트라 하며 다음과 같은 경우 실행됩니다.

1. 자바스크립트에 의한 노드추가,삭제
2. 브라우저 창의 리사이징
3. HTML 요소의 레이아웃을 변경을 발생시키는 스타일 변경
   )

## Script 태그를 **head** 태그보다 **body** 태그에 넣는 이유는 무엇이고 태그 삽입 **순서에 상관없이** 태그를 삽입할 수 있는 방법은 무엇이 있을까요?

1. html은 렌더링 엔진에 의해 순차적으로 파싱되며 중간에 다른 파일을 로드하는 link,script 태그 등을 만나면 DOM생성을 중단합니다.

2. DOM의 생성된 후의 위치에 script 태그를 두는 것이 중요합니다.

head태그에 삽입할 경우 DOM트리가 완성되지 않은 상황이기 때문에 자바스크립트 코드 중 DOM API가 쓰일 경우 에러가 발생할 수 있습니다.

때문에 DOM 생성되기전인 head 태그보다 body태그 끝쪽에 위치시키는 것이 좋습니다.

3. 순서에 상관없이 태그를 삽입할 수 있는 방법은 script 태그의 어트리뷰트로 async나 defer을 부여해주면 됩니다. 이는 비동기적으로 script 태그를 실행시킬 수 있으므로 에러를 발생시키지 않습니다.

## ajax의 개념,탄생동기과 장단점

- 개념
- 탄생동기
- 장단점
- hmlhttprequest

ajax란 자바스크립트를 사용하여 브라우저가 서버에게 비동기 방식으로 데이터를 요청하고,
서버가 응답한 데이터를 수신하여 웹페이지를 동적으로 갱신하는 프로그래밍 방식이다.

ajax등장이전에는 웹페이지가 데이터변경을 할 때에 html전체를 다시 요청하여 받아와 변경되지 않아도 되는 부분까지
불필요하게 응답되어 새로고침과 같이 화면이 깜빡이는 비효율적인 단점이 있었다.

또한 필요한 부분을 업로딩할 때마다 새로운 html을 제작해줘야되니 이 또한 비효율적이다.
(예를 e-commerce 웹사이트로 비추어 보았을 때, 새로운 상품 등록을 할 때마다 그 상품하나 때문에 html을 새로 작성해야한다.
뿐만 아니라 요즘같이 실시간으로 데이터가 업데이트되는 페이스북,인스타그램 등을 보았을 때도 ajax를 사용하지않는 정적웹이면
짧은 시간동안 생성되는 데이터와 비례하여 해당 html문서를 생성해야한다는 것이다.)

하지만 ajax는 필요한 데이터를 비동기적으로 받아와 필요한 부분을 업데이트 할 수 있다.
따라서 필요한 부분만 부분적으로 업데이트되고, 변경될 필요가 없는 부분은 변경되지 않게 할 수 있다.

다만 정적인 웹에서는 처리해야할 데이터가 적기 때문에 요청과 응답이 비교적 빠를 수 있지만
ajax를 사용하는 동적인 웹은 정적인 웹에 비해 요청,응답이 비교적 느려 웹 업로딩이 느릴 수 있다는 단점도 있을 수 있다.

ajax는 XMLHttpRequest 객체를 기반으로 작동한다.  
XMLHttpRequest는 http 비동기 통신을 위한 프로퍼티 및 메서드를 제공한다.
이를 간편하게 사용할 수 있는 API로는 fetch 또는 라이브러리 ajax가 있다.
이는 XML,json,txt,html 등 다양한 데이터 포멧을 주고 받는다.

**reference**

- https://developer.mozilla.org/en-US/docs/Web/Guide/AJAX/Getting_Started
- javascript deep dive
- https://titus94.tistory.com/4

## Rest API란?(Representational State Transfer)

Rest는 Http를 기반으로 클라이언트가 서버의 리소스에 접근하는 방식을 규정한 아키텍처이고  
Rest API는 Rest를 기반으로 구성한 API이다.

Rest API는 3가지 구성요소로 이루어지는데 자원,행위,표현으로 이루어진다.
자원은 URI로서 리소스를 얻어오고자하는 origin을 말하고  
행위는 해당 자원에 대한 http 요청 메서드(get,post,patch,delete 등)를 말한다.
표현은 행위를 할 때 서버에 같이 보낼 구체적 내용이며 주로 데이터의 추가,수정을 할 때 보낸다.

따라서 Rest API로 설계할 때에는 얻어오고자하는 리소스를 표현하기 위해 알맞은 URI 표현하고 해당 리소스에 대해 어떻게 처리할 것인지를 표현하기 위해 적절한 http 요청 메서드를 사용해야한다.

## GET과 POST가 어떻게 다르게 쓰이는지 말씀해주세요.

```

Get과 post는 Rest API중 대표적인 메서드로서
주로 GET은 서버에게 요청하여 특정 리소스를 취득하는데 사용하고
POST는 클라이언트측에서 서버에 없는 특정 리소스를 서버에게 보낼 때에 주로 사용합니다.

하지만 get은 리소스를 얻어올 때, post는 리소스를 보낼 때, 이렇게 정해진 것이 아니라 get,post 둘다 서버에 특정 데이터를 보낼 때 사용할 수 있습니다.

다만 , GET은 보내고자하는 데이터가 URL에 드러나 보안성이 취약하다는 점과
데이터양이 많으면 URL의 길이제한이 있어 보내기 힘듭니다.
하지만 POST는 데이터를 Body(payload)에 담아 보내 데이터가 보이지 않다는 점에서 보안성도 있으며 길이 제한이 없어 주로 데이터를 보낼 때에 post로 보내는 것입니다.

따라서 서버의 리소스를 조회할 때에는 GET, 서버에게 리소스를 보낼 때에는 POST HTTP 요청 메서드를 사용합니다.
```

## JSON이란?

클라이언트와 서버가 http 통신을 할 때에 주고 받는 텍스트 데이터 포멧형식이다.

주로 ajax로 비동기 통신할 때 header의 content-type으로 설정하는 텍스트 데이터 포멧이다.

클라이언트 측에서 json데이터로 통신할 때에 서버에서 보낼 때는 문자열화(JSON.stringfy)에서 보내고 서버측에서 클라이언트측에 보낼 때는 객체화(JSON.parse)하여 보낸다.

## 비동기 처리를 할 때 기존 콜백함수로 처리하는 것보다 Promise처리하는 것의 장점은?

- 기존의 비동기 응답값 처리 => 콜백함수
- 그로 인한 문제점
- 이를 해결할 promise

기존에 비동기 처리에 대한 응닶값을 활용하기 위해서는 콜백함수로 처리해야했다.

그러다보니 응답값을 활용하여 또 다른 비동기 처리를 해야할 상황이 중첩되다보면 콜백함수가 중첩되는 경우가 발생하는데 이를 콜백지옥이라고 한다.

이는 가독성이 안 좋을 뿐더라 유지보수도 힘들어지게 되는 단점이 있다.

이를 위해 등장한 기능이 promise이다. promise는 비동기처리에 대한 응답값을 then이라는 후속처리 메서드로 순차적으로 처리할 수 있으며 에러값도 catch를 통해 잡아낼 수 있어 위 문제점을 해결할 수 있는 장점을 가지고 있다.

**Ref**

- 딥다이브

## async/await에 관해 설명하시오.

async/await는 프로미스에 대한 응답값을 후속처리메서드를 활용하지 않고 async/await라는 키워드로 순차적으로 조작할 수 있는 기능이다.

여러개의 비동기 동작을 실행시킬 코드가 있다하였을 때 , 이에 순서를 정하여 해당 코드가 진행되기전까지 다음 비동기 코드가 동작하지 않도록 순서를 정해줄 수 있는 순차적인 장점이 있다.

## fetch와 axios의 차이

fetch는 비동기 http 통신을 위한 web api이고 xmlHttpRequest API보다 간편하게 사용할 수 있는 API이다.
axios는 xmlHttpRequest을 기반으로 한 라이브러리이다.

둘의 사용방식은 비슷한 axios가 추가적인 기능이 더 많다.
fetch는 Web API이기 때문에 브라우저에서만 실행이 가능하지만 axios는 브라우저뿐만이 아니라 node.js환경에서도 실행이 가능하다.
또한 여러 origin에 대한 API 요청할 상황이 있을 때 , 각 origin에 대한 요청이 복잡하고 번거로워질 수 있는데 axios를 사용할 때에는  
여러가지 인스턴스를 생성하여 체계적으로 각 오리진마다 헤더 설정 및 요청을 관리할 수 있다.

또한 fetch는 xmlHttpRequest보다 간편하게 사용할 수는 있지만 xmlHttpRequest에 있는 기능이 없다.  
하지만 axios는 xmlHttpRequest기반으로 해당 기능들을 사용할 수 있다는 장점이 있다.

전반적으로 axios가 fetch보다 많은 기능을 가지고 있지만 해당 기능들이 사용되지 않는데 굳이 axios라는 라이브러리를 설치해 사용할 필요는 없다.  
상황에 맞춰 고민해보고 어떤 도구를 사용할지 고민해보는 것이 좋다.

**Ref**

- https://velog.io/@kcj_dev96/fetch

## http와 https 차이

http는 웹으로 비추어보았을 때, 클라이언트와 서버가 통신할 수 있도록 하는 프로토콜이다.
프로토콜이란 통신을 위한 규약을 말한다.
http는 html와 같은 여러 가지 리소스등을 교환할 수 있게 해준다.

https는 http의 보안성이 보장된 버전이다.
https위에서 클라이언트와 서버는 안전하게 데이터를 교환할 수 있으며 보안성을 위해 TLS와 SSL을 사용한다.

**Reference**

- https://developer.mozilla.org/en-US/docs/Glossary/Protocol
- https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview
- https://developer.mozilla.org/en-US/docs/Glossary/https
- https://developer.mozilla.org/en-US/docs/Glossary/SSL
